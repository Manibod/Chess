Possible Moves
	Checked
		new var isChecked
		propose only moves that UnChecked
		move out, block, take the piece
	Double Checked
		new var isChecked
		propose only King move
		move out
	King not checked
		method isChecked(board_2D) for each possible moves
	Pinned			 not propose moves for the pinned piece
	
	
	Pawn first move	 propose according to first move or nah
	Castle
		if king and all condition met
			propose MOVE()
	En passant		 propose en passant
Move
	Castle:		 	 move multiple piece 
	En passant:	 	 eaten piece not on pos end

Eval
	Castle
		if last move has 2 pieces
			castle to false
	Pawn first move
		if last move pawn and first move
			delta_rep = 1
	En passant
		if last move pawn, ...
		give possible moves to next turn
	
	Check
		form board_2D
		check if possible moves to unchecked
		if not: checkmate
		give possible moves to next turn (already calculated)
	CheckMate
		if no possible moves
		end game
	Discovery check
		nohting to do (handled by check)
	Stalemate
		check possible moves for every piece
		stop if at least one
	Promotion
		if last move is pawn and at the end
		prevoir new screen
	InsuffecientMat
		start by checking number of pieces left
		King vs King
		King and Bishop vs. King
		King and Knight vs. King
		King and Bishop vs. King and Bishop (with Bishops on the same color)
		...
	FiftyMoves
		var count that resets if last move is pawn or a captured occured
		if count >= 50
	Repetition
		keep record of moves
		hash board_2D state
		check if 3 times the same hash in record
		if move pawn or captured: move idx up from where start looking the record

Game
	is_checked = bool
	can_castle_white
	can_castle_black
	en_passant = List[Move()]
	out_of_checked_moves = []
	get_possible_moves()
		for each move
			if not isChecked(board_2D)
				append
	
	is_checked(board_2D)
	get_out_of_checked_moves()
		for each piece
			get possible moves()
				for each move
					isChecked(board_2D)
	evaluation
		if last move pawn (0, 2)
			check if pawn next to end pos



__________________________________________________________________________


Castle
	Get possible moves
		if King not moved, rook not moved, path clear, no check path:
			possible_moves(Move(pos_end, is_castle=0-0))
	
	Move
		if move.is_castle:
			castle()
	
	Evaluate
		piece.has_moved = true
		(king and rook)(assert king and rook at right pos)

Pawn first move	
	Get possible moves
		-----
	Move
		-----
	Evaluate
		piece.has_moved = true
		set delta_rep = 1

En passant
	Evaluate
		if last_move.piece == PAWN and (pos_end-pos_start) = 2 and pawn next to it
			Move()
	Get possible moves
		if piece = PAWN and same pos as self.en_passant
			append
	Move
		-----

class Move:
    def __init__(self, pieces, pos_start, pos_end, piece_captured, board_2D):
        self.pieces = piece
        self.pos_start = pos_start
        self.pos_end = pos_end
        self.piece_captured = piece_captured
        self.board_2D = copy.deepcopy(board_2D)
		self.is_castle = None, 0-0, 0-0-0

has_moved
	king
	rook
	pawn